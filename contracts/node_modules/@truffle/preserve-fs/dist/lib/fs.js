"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.targetPath = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = require("path");
async function* targetPath(options) {
    const { path } = options;
    const stats = await fs_1.default.promises.stat(path);
    if (stats.isFile()) {
        return {
            source: yield* pathContent(options)
        };
    }
    else if (stats.isDirectory()) {
        return {
            source: yield* pathContainer(options)
        };
    }
}
exports.targetPath = targetPath;
async function* pathContent(options) {
    const { path, verbose, controls } = options;
    const { step } = controls;
    const task = verbose
        ? yield* step({ message: `Opening ./${path}...` })
        : controls;
    const content = fs_1.default.createReadStream(path);
    if (verbose) {
        yield* task.succeed();
    }
    return content;
}
async function* pathContainer(options) {
    const { path, verbose, controls } = options;
    const { step } = controls;
    const task = verbose
        ? yield* step({ message: `Reading directory ${path}...` })
        : controls;
    const directory = await fs_1.default.promises.readdir(path);
    const entries = [];
    for (const childPath of directory) {
        const entry = yield* pathEntry({
            ...options,
            controls: task,
            path: childPath,
            parent: path
        });
        entries.push(entry);
    }
    if (verbose) {
        yield* task.succeed();
    }
    return {
        entries
    };
}
async function* pathEntry(options) {
    const { path, parent } = options;
    const stats = await fs_1.default.promises.stat(path_1.join(parent, path));
    if (stats.isFile()) {
        return {
            path,
            source: yield* pathContent({
                ...options,
                path: path_1.join(parent, path)
            })
        };
    }
    if (stats.isDirectory()) {
        return {
            path,
            source: yield* pathContainer({
                ...options,
                path: path_1.join(parent, path)
            })
        };
    }
}
//# sourceMappingURL=fs.js.map