"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertCollectionToSource = exports.convertResultsToTarget = exports.fetch = void 0;
const iter_tools_1 = require("iter-tools");
const fetch = async ({ cid, ipfs }) => {
    const results = ipfs.get(cid);
    return await exports.convertResultsToTarget(results);
};
exports.fetch = fetch;
const convertResultsToTarget = async (results) => {
    const root = new Map([]);
    for await (const result of results) {
        // skip directories
        if (!result.content) {
            continue;
        }
        // normalize path to start with "./"
        const path = [".", ...result.path.split("/").slice(1)];
        const concatenatedContent = await iter_tools_1.asyncToArray(iter_tools_1.asyncConcat(result.content));
        const stringifiedContent = concatenatedContent.toString();
        updateCollection(root, path, stringifiedContent);
    }
    const source = await exports.convertCollectionToSource(root.get("."));
    return { source };
};
exports.convertResultsToTarget = convertResultsToTarget;
const updateCollection = (collection, path, content) => {
    const [childPath, ...remainingPath] = path;
    // if we're at a leaf of the tree we update the collection
    if (remainingPath.length === 0) {
        collection.set(childPath, content);
        return;
    }
    // otherwise, make sure we have the first part of the path in our collection
    let child;
    const entry = collection.get(childPath);
    if (entry === undefined || typeof entry === "string") {
        // for string case, something went wrong:
        // we tried to path through some content
        child = new Map([]);
        collection.set(childPath, child);
    }
    else {
        child = entry;
    }
    // then recurse
    updateCollection(child, remainingPath, content);
};
const convertCollectionToSource = async (collectionNode) => {
    if (typeof collectionNode === "string") {
        return collectionNode;
    }
    return {
        entries: await Promise.all(Array.from(collectionNode.entries()).map(async ([path, result]) => ({
            path,
            source: await exports.convertCollectionToSource(result)
        })))
    };
};
exports.convertCollectionToSource = convertCollectionToSource;
//# sourceMappingURL=fetch.js.map